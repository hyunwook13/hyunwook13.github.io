---
layout: post
title: 24장 - 부분적 경계
tags: [clean-architecture]
---

- 아키텍쳐 경게를 완벽하게 만드는 데에는 많은 비용이 든다
    - Input, Output를 위한 데이터 구조
    - Boundary 인터페이스
    - 두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는 데 필요한 모든 의존성을 관리

    → 엄청난 노력을 기울여야 하고, 유지하는 데도 또 엄청난 노력이 듬
- 근데 사람에 따라 필요없다고 생각할 수 있고 때에 따라 부분적으로만 구현할 수도 있음

### 마지막 단계를 건너뛰기

- 부분적 경계를 생성하는 방법 → 컴포넌트화 작업은 하되 컴포넌트로 쪼개지는 않는다
    - 쌍방향 인터페이스도 그 컴포넌트에 있고, 입력•출력 데이터 구조도 거기에 있으며, 모든 것이 완전히 준비되어 있다.
    - 다수의 컴포넌트를 관리하는 작업을 하지 않아도 된다는 장점이 존재
    
    ex) FitNesse라는 서비스를 테스트할 수 있도록 분리는 해뒀지만 유저가 2개의 컴포넌트를 각각 다운하는 걸 원치 않았기에 하나의 컴포넌트로 관리했음
    

### 일차원 경계

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로
쌍방향 Boundary 인터페이스를 사용
    - 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 드는 문제
- 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 더 간단한 구조

![24-1](/assets/images/clean-architecture/24-1.png)

- 이 방식은 **미래의 아키텍처 경계 설정을 위한 준비 작업**이라는 점이 명확하다.
- Client와 ServiceImpl 간의 **의존성 역전(DIP)** 원칙이 적용되었기 때문에 구조적으로 격리되어 있다.
- 이 구조는 **빠르게 실제 분리 배포가 가능한 형태**로 전환될 수 있다는 점에서 장점이 있다.
- 단, **쌍방향 인터페이스 없이** 설계되어 있어, 개발자와 아키텍트 간 협력이 부족하다면 **비밀 통로(암묵적 의존성)** 문제가 발생할 수 있다.

### 퍼사드

![24-2](/assets/images/clean-architecture/24-2.png)

- 위의 일차원 경계보다 더 단순한 경계로는 퍼사드가 존재한다
- 의존성 역전까지도 희생한다
- Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 
    - 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.
- 하지만 모든 Client 클래스가 퍼사드 클래스에 의존함