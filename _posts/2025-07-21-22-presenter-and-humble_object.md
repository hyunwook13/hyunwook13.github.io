---
layout: post
title: 23장 - 프레젠터와 험블 객체
tags: [clean-architecture]
---

- 프레젠터는 험블 객체 패턴을 따른 형태
- 아키텍처 경계를 식별하고 보호하는 데 도움이 됨

### 험블 객체 패턴

- 험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었음
- 아이디어는 매우 단순함
    - 행위들을 두 개의 모듈 또는 클래스로 나눈다.
        1. 테스트하기 어려운 행위를 모두 갖은 험블 객체
        2. 험블 객체 그 외 나머지
        - ex) GUI 단위 테스트 → 프레젠터와 험블 객체를 통해서 쉬운 GUI 단위 테스트 진행 가능

### 프레젠터와 뷰

- 뷰는 험블 객체이고, 테스트 하기 어려움
    - 이 객체에 포함된 코드는 최대한 가볍게 유지
    - 뷰는 데이터를 GUI로 이동시킬 뿐, 실제 처리를 하지는 않음
- 프레젠터는 테스트하기 쉬운 객체
    - 어플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것
    
    → 이를 통해 뷰는 데이터를 화면에 띄우기만 하도록 함
    
    ex) 날짜 표시를 하기 위해 ( View는 험블해진다. )
    
    1. App → Presenter ( Date ) 전달
    2. Presenter는 받은 날짜를 적당한 문자열 포맷으로 변환
    3. Presenter → View Model
    4. ViewModel → View

### 테스트와 아키텍쳐

- 테스트 용이성은 좋은 아키텍쳐가 지녀야 할 속성으로 오랫동안 잘 알려짐
    - 그에 대한 가장 좋은 예시가 험블 객체 패턴
    - 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의되기 때문
    - 프레젠터 와 뷰 사이의 경계는 이러한 경계 중 하나이며, 이 밖에도 수많은 경계가 존재

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이 Database Gateway가 위치
    - 이 게이트웨이는 다형적 인터페이스로, 애플리케이션이 데이터베이스에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메서드를 포함한다.
    - ex) 예를 들어 애플리케이션에서 어제 로그인한 모든 사용자의 Last name을 알 수 있어야 한다
    1. UserGateway 인터페이스는 getLastNamesofuserswhoLoggedInAfter라는 메서드를 제공
        1. 메서드는 날짜를 인자로 받아서 사용자 성들을 담은 목록을 반환
    2. 유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출
        1. 인터페이스의 구현체는 데이터베이스 계층에 위치 ( 이 구현체는 험블 객체 ). 
    3. 구현체에서 직접 SOL을 사용하거나 데이터베이스에 대한 임의의 인터페이스를 통해 게이트웨이의 메서드에서 필요한 데이터에 접근한다. 
        1. 이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다. 
        2. 따라서 테스트하기 쉬운데, 게이트웨이는 스텝 stub 이나 테스트 더블(est double) 로 적당히 교체할 수 있기 때문이다.

### 데이터 매퍼

- 하이버네이트와 같은 ORM은 어느 계층에 속할까?
- ORM와 같은 건 존재하지 않음
    - 객체는 데이터 구조가 아니기 때문에
    - 최소한 객체를 사용하는 사람 관점에서 객체는 데이터 구조가 아니다.
    - 데이터는 모두 Private으로 선언되어 있어서 사용자는 Public 메소드만 볼 수 있음
        
        → 사용자 관점에서는 객체는 단순히 오퍼레이션의 집합
        
    - 차라리 데이터베이스에서 정보를 가져와 구조에 맞게 매핑해주기 때문에 데이터 매퍼라고 하는게 나아 보인다
    - ORM은 DB 계층에 존재하자

### 서비스 리스너

- 만약 애플리케이션이 다른 서비스와 반드시 통신해야 한다면, 또는 애플리케이션에서 일련의 서비스를 제공해야 한다면, 우리는 여기에서 서비스 경계를 생성하는 험블 객체 패턴을 발견할 수 있을까?
→ 당연하다!
1. 애플리케이션이 데이터를 간단한 구조 형태로 로드
2. 경계를 가로질러서 특정 모듈로 전달
3. 데이터를 또 적절한 포맷으로 만들어서 외부 서비스로 전송

---

반대 입장

1. 서비스 리스너가 인터페이스로부터 데이터를 수신
2. 애플리케이션에서 사용할 수 있도록 간단한 데이터 구조로 포맷을 변경
3. 서비스 경계를 가로질러서 내부로 전달