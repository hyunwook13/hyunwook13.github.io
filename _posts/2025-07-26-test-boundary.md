---
layout: post
title: 28장 - 테스트 경계
tags: [clean-architecture]
date: 2025-07-30 10:00:00 +0900
---

- 테스트는 시스템의 일부, 아키텍쳐에도 관여함
    - 시스템의 나머지 요소가 아키텍쳐에 관여하는 것과 동등하게
    - 어떤 면에서는 정말 평범하게 관여함
    - 또 다른 면에서는 상당히 독특하게 관여함

### 시스템 컴포넌트인 테스트

- 테스트에 관련하여 상당한 혼동이 있다
    - 어떤 종류의 테스트가 있는가?
    - 단위 테스트와 통합 테스트 는 서로 다른가?
    - 인수 테스트, 기능 테스트, Cucumber 테스트, TDD 테스트, BDD 테스트, 컴포넌트 테스트 등은 어떻지?
- 이 책은 이러한 논란에 휘말리고 싶지 않은데, 다행히도 그럴 필요도 없다.
    
    → 아키텍처 관점에서는 모든 테스트가 동일하기 때문이다. 
    
    - TDD로 생성한 아주 작은 테스트이든, 아니면 대규모의 FitNesse, Cucumber, SpecFlow, JBehave 테스트이든
        
        → 이들 테스트는 아키텍처적으로 모두 동등하다.
        
- 테스트는 태생적으로 의존성 규칙을 따른다.
- 테스트는 세부적이며 구체적인 것으로, 의존성은 항상 테스트 대상이 되는 코드를 향한다.
    - 실제로 테스트는 아키텍처에서 가장 바깥쪽 원으로 생각할 수 있다.
    - 시스템 내부의 어떤 것도 테스트에는 의존하지 않으며, 테스트는 시스템의 컴포넌트를 향해, 항상 원의 안쪽으로 의존한다.
- 또한 테스트는 독립적으로 배포 가능하다.
    - 사실 대다수의 경우 테스트는 테스트 시스템에만 배포하며, 상용 시스템에는 배포하지 않는다.
    - 따라서 심지어 배포 독립성이 달리 필요하지 않은 시스템에서도 테스트는 독립적으로 배포될 것이다.
- 테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다.
- 테스트가 시스템 운영에 꼭 필요치는 않다.
- 어떤 사용자도 테스트에 의존하지 않는다.
- 테스트 의 역할은 운영이 아니라 개발을 지원하는 데 있다.
- 그렇다고 해서 테스트가 시스템 컴포넌트가 아니라는 뜻은 아니다.
- 사실 많은 면에서 테스트는 다른 모든 시스템 컴포넌트가 반드시 지켜야 하는 모델을 표현해준다.

### 테스트를 고려한 설계

- 운영에 포함되지 않고, 시스템과 독립적으로 떨어져 있으니까, 테스트는 마치 본 시스템의 일부가 아닌 것처럼 취급된다.
    - 이러한 관점으로 인해 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워지는 치명적인 문제가 존재
- 문제는 결합이다.
    - 시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야만 한다.
    - 시스템 컴포넌트에서 생긴 아주 사소한 변경도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다.
- 상황은 더 심각해질 수 있다.
    - 시스템의 공통 컴포넌트가 변경되면 수백, 심지어 수천 개의 테스트가 망가진다.
    - 이 문제는 깨지기 쉬운 테스트 문제 Fragile Tests Problem로 알려져 있다.
    - ex) GUI 테스트
        - 로그인 → 특정화면인 상황에서 로그인이 변경되거나 삭제되면 그 이후에는 싹다 실패
- 변동성이 있는 것에 의존하지 말라
    - 테스트를 고려해서 설계

### 테스트 API

- 목표를 달성하려면 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만들면 됨
    - 이러한 API는 보안 제약사항을 무시할 수 있으며, (데이터베이스와 같은) 값비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야만 한다.
- 이 API는 사용자 인터페이스가 사용하는 인터랙터와 인터페이스 어댑터들의 상위 집합이 될 것이다.
- 테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.
    - 단순히 테스트를 UI에서 분리하는 것만이 아닌, 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는 게 목표다.

→ UI 없이 업무 규칙을 테스트하고 싶다면 API를 만들어서 사용, 이렇게 만들어진 API는 인터페이스와 동일한 형태와 역할을 함

### 구조적 결함

- 구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져 나가는 유형이다.
    - ex) 아래의 상황처럼 회원가입 버튼이 로그인버튼으로 변경이 되버리면 테스트가 다 깨짐
    
    ```java
    @Test
    void test_회원가입_버튼을_누르면_회원이_추가된다() {
        new SignupPage().clickSignupButton();
        assertTrue(database.hasUser("tubi"));
    }
    ```
    
    - 그러면 변경해야 하는 테스트가 많아지고, 변경하기 어려운 존재가 되기에, 뻣뻣하게 만들어버림
- 테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있다.
    - 이렇게 만들면 상용 코드를 리팩터링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않는다.
    - 또한 테스트를 리팩터링하거나 진화시킬 때도 상용 코드에는 전혀 영향을 주지 않는다.
    - 
- 이런 상황이 유지되면, 테스트 케이스가 많아져 구체적이고 더 특화된 형태로 변함
    - 반대로 상용코드는 재사용을 위해서 더 추상적이고, 더 범용적인 형태로 변함

### 보안

- 테스트 API가 지닌 강력한 힘을 운영 시스템에 배포하면 위험에 처할 수 있다.
- 위험을 피하고 싶다면, 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야 한다.