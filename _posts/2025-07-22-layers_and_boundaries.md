---
layout: post
title: 25장 - 계층과 경계
tags: [clean-architecture]
date: 2025-07-22 10:00:01 +0900
---

- 시스템이 세가지 컴포넌트로만 구성된다고 생각하기 쉬움
    - UI, 업무 규칙, 데이터베이스
- 몇몇 단순한 서비스에서는 이정도로 충분할 지 모르지만, 대다수의 시스템에서 컴포넌트 개수는 이보다 훨씬 많음

### 옴퍼스 사냥 게임

- 1972년 발매한 옴퍼스 사냥 게임을 예시로 들어보자
    - 텍스트 기반 게임, Go East, Shoot West와 같은 매우 단순한 명령어를 사용
    - 플레이어는 명령을 내리고, 컴퓨터는 그 명령을 수행하며 옴퍼스를 잡는 게임

→ if 텍스트 기반 UI는 유지하면서 게임규칙을 분리해서 다양한 언어로 할 수 있도록 해보자

- 소스 코드 의존성을 적절히 관리하면, UI 컴포넌트가 어떤언어를 사용하더라도 게임 규칙을 재사용할 수 있다.
- 게임 규칙은 어떤 종류의 인간 언어가 사용되는지 알지도 못할 뿐만 아니라 신경 쓸 이유도 없다.

 \+ if 게임의 상태를 영속적인 저장소에 유지한다고 가정

- 어디에 저장을 하던 우리는 게임규칙이 세부사항을 알지 않기를 바람
    ![25-1](/assets/images/clean-architecture/25-1.png)
    
    - 준수된 의존성 규칙 그래프

### 클린 아키텍쳐?

- 변경의 축이 생길 다양한 가능성이 있고, 이 축에 의해 아키텍쳐 경계가 잠재되어 있을 수 있음
    - 텍스트를 주고 받는 매커니즘의 변경의 요청
    - 사용하는 언어
    - 저장하는 방식
- 그래서 수많은 API를 생성해야 할 수 있다
    ![25-2](/assets/images/clean-architecture/25-2.png)
    
    - 점선으로 된 부분은 API를 정의하는 추상 컴포넌트, 그 위나 아래에 컴포넌트를 구현
        - Game Rules에서 정의된 API를 통해서 언어 정의
        - 여기서 정의된 언어 컴포넌트를 통해 어떻게 전달할지를 정하는 Text Delivery를 정의
    - Game Rules, Language 컴포넌트에는 다형적인 Boundary 인터페이스를 확인할 수 있음
        
        ![25-3](/assets/images/clean-architecture/25-3.png)
        
    - 단순화한 다이어그램

### 흐름 횡단하기
![25-4](/assets/images/clean-architecture/25-4.png)

- 위 예제처럼 데이터 흐름은 항상 두 가지일까? → 절대로 X
- 만약 Network 컴포넌트가 생긴다면 3가지로 됨
    - 시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리될 것

### 흐름 분리하기

- 모든 흐름이 결국에는 상단의 단일 컴포넌트에서 서로 만난다고 생각할 수도 있다.

> 인생이 이처럼 단순하면 얼마나 좋을까! 물론 현실은 훨씬 복잡하다.
> 

- 움퍼스 사냥 게임의 GameRules 컴포넌트를 생각해 보자.
    - 게임 규칙 중 일 부는 지도와 관련된 메커니즘을 처리한다.
        - 이 규칙들은 동굴이 서로 어떻게 연결될지, 각 동굴에 어떤 물체가 위치할지
        - 플레이어가 동굴에서 동굴로 이동하는 방법
        - 플레이어가 반드시 처리해야 하는 사건을 결정하는 방법
    - 하지만 이보다 더 높은 수준에는 또 다른 정책 집합이 존재한다.
    - 플레이어에 대한 상태를 관리하는 정책
        ![25-5](/assets/images/clean-architecture/25-5.png)