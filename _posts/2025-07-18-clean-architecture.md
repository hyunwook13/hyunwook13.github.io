---
layout: post
title: 22장 - 클린 아키텍쳐
tags: [clean-architecture]
---

- 지난 시절 여러가지 아키텍쳐
    - 육각형 아키텍쳐 ( 포트와 어댑터 ) - 앨리스터 코오번
    - TDD
    - DCI
    - BCE
- 이 아키텍쳐들의 세부적인 면은 차이가 있더라도 내용과 목표는 비슷함
    - 계층으로써 **관심사의 분리**
    - 각 아키텍쳐는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.
- 아키텍쳐 모두 시스템이 다음과 같은 특징을 갖음
    - 프레임워크 독립성 - 특정 프레임워크에 의존하지 않기에 다양한 프레임워크를 제약없이 사용하도록 할 수 있다
    - 테스트 용이성 - 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트할 수 있다.
    - UI 독립성 - 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다. 예를 들어 업무 규칙을 변경하지 않은 채 웹 UI를 콘솔 UI로 대체할 수 있음
    - 데이터베이스 독립성 - 업무규칙은 데이터베이스에 포함되지 않아 다양한 데이터베이스를 사용할 수 있음
    - 모든 외부 에이전시에 대한 독립성. 실제로 업무 규칙은 외부 세계와의 인 터페이스에 대해 전혀 알지 못한다.


![22-1](/assets/images/clean-architecture/22-1.png)

### 의존성 규칙

- 안쪽으로 들어갈수록 고수준의 소프트웨어가 됨
- 바깥쪽은 매커니즘, 안쪽은 정책

> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
> 

- 내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못함
- 특히 내부의 원에 속한 코드는 외부의 원에 선언된 어떤 것에 대해서도 그 이름을 언급해서는 절대 안됨
    - ex) 함수, 클래스, 변수, 소프트웨어 엔티티 등
    - 뿐만 아니라 외부에 선언된 데이터 형식 또한 ( 외부의 원에 있는 프레임워크가 만든거면 더더욱 안됨 )
    
    → 외부의 원이 내부의 원에게 어떤 영향도 주지 않기를 바람
    

### 엔티티

- 전사적인 업무 규칙을 캡슐화함
    - 엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다.
    - 기업의 다양 한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.
    - 엔티티는 다양한 애플리케이션에서 재사용될 수 있도록 설계되어야 하며, 단일 애플리케이션의 업무 객체로 쓸 때는 외부 변화(페이지 네비게이션, 보안 등)에도 영향받지 않는 고수준의 비즈니스 규칙만 캡슐화해야 합니다.

### 유스케이스

- 유스케이스 계층은 애플리케이션에 특화된 업무 규칙을 담아 시스템의 모든 시나리오(유스케이스)를 구현하고, 엔티티가 자신의 핵심 규칙을 사용해 목적을 달성하도록 데이터 흐름을 조정합니다.
- 당연하지만 엔티티 자체가 다른 계층에 영향을 주면 안된다
- 유스케이스의 세부사항이 변경된다면 유스케이스 또한 영향을 받는다

### 인터페이스 어댑터

- 유스케이스가 편리한 형식 → DB나 외부 에이전시가 편리한 방식으로 변환
- 이 계층에는 Presenter, View, Controller 같은 GUI 구성 요소와, DB나 API 호출 코드를 직접 다루지 않는 순수한 변환 로직만 포함되어야 한다.
- 엔티티·유스케이스 쪽은 외부 변화에 영향을 받지 않도록 하되, 이 계층 내부에서만 SQL 쿼리나 ORM 코드를 작성해 데이터 접근 세부사항을 캡슐화한다.
- 모든 외부 프레임워크 종속 코드는 이 어댑터 계층에만 머물러야 하며, 계층을 벗어나서는 절대 직접 사용되어선 안 된다.
- 데이터 → 유스케이스 계층에서 사용하기 위한 형태로 전달하기 위한 어댑터가 필요함

### 프레임워크와 드라이버

- 프레임워크와 드라이버는 가장 바깥 쪽 원을 차지함
- 모든 세부사항이 존재함
    - DB, 웹
    - 이렇게 함으로 피해를 최소화 함

### 원은 네 개여야만 하나?

- 예시일 뿐 더 필요할 수 있음
- 허나 어떠한 경우에도 전에 말했던 의존성 규칙은 지켜져야 함
    - 의존 방향은 바깥에서 안, 안으로 들어갈 수록 추상화 진행

### 경계 횡단하기

- 경계 횡단은 위의 이미지에 존재
    - 제어 흐름 : 컨트롤러 → 유스케이스 → 프레젠터
    - 소스 코드 의존성
        - 둘다 인터페이스 어댑터 레이어이기 때문에 유스케이스에서 프레젠터를 사용하게 되면 규칙이 꺠져버림
        - DIP를 통해서 유스케이스 레이어 내부에 프로토콜을 배치
        - 외부의 프레젠터에서 이걸 의존하여 문제를 해결
- 경계를 넘어야 하는 문제가 발생한다면 위와 같이 해결할 수 있다.

### 경계를 횡단하는 데이터는 어떤 모습인가

- 외부 어댑터(예: DB 프레임워크)가 제공하는 복잡한 데이터 구조(예: 행(row) 포맷)를 내부로 그대로 넘기면, 내부가 외부 구현 세부사항에 의존하게 된다.
- 그래서 어댑터 계층은 그 경계를 가로질러 전해질 데이터를 **항상 내부에서 가장 편리하게 사용할 수 있는** 단순한 형태(예: Data Transfer Object, 함수 인자, 해시맵 등)로 변환해야 한다.
- 핵심은 “경계를 넘는 데이터는 가급적 간단히” 하여, 내부 로직이 외부 구조나 프레임워크 변화에 묶이지 않도록 만드는 것이다.

### 전형적인 시나리오

![22-2](/assets/images/clean-architecture/22-2.png)

- 들어온 데이터를 모아서 Controller에 제공
- InputBoundary 인터페이스를 통해 usecase로 전달
- 받은 단순 객체(POJO)를 해석해 Entities를 조작
- DataAccessInterface로부터 필요한 데이터를 로드한 뒤 이들로 OutputData를 구성, OutputBoundary로 전달
- Presenter는 OutputData를 화면용 ViewModel(문자열·플래그 등)로 변환·재구성
- View는 이 ViewModel을 그대로 렌더링
    - 계층 간 모든 의존성은 안쪽으로만 향하며, UI나 DB 코드는 오직 어댑터 계층 안에만 위치한다.