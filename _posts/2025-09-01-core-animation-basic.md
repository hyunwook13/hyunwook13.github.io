---
layout: post
title: Core Animation - Basic
tags: [swift, core-animation]
date: 2025-09-01 10:00:00 +0900
---

- Core Animation에서 CALayer는 핵심요소
    - 레이어는 2D 평면이지만, 3D 공간위에 배치됨
    - 뷰처럼 위치, 콘텐츠, 시각적 속성을 관리
        - 허나 뷰와 달리 비트맵을 어덯게 보여줄지에 대한 상태 정보를 관리

→ 레이어는 뷰의 시각적 데이터를 담는 모델 객체이다.

- 대부분의 레이어는 앱 안에서 직접 그리지 않음
    - 앱이 제공하는 콘텐츠를 **비트맵으로** 저장
    
    → 뷰에서 화면 이동 애니메이션을 한다고 가정한다면, 실제 뷰는 좌표만 변경될뿐 다시 그리지 않고, 그동안 애니메이션에서 비트맵을 갖고 움직이는 뷰를 GPU를 통해 그린다
    
- 기존의 전통적인 뷰 기반 드로잉과 레이어 기반 드로잉의 차이점
    - 기존 전통적인 뷰 기반은 뷰 자체를 말 그대로 다시 “draw” 함 → CPU의 사용량 증가
    - 허나 레이어 기반은 뷰 자체는 가만히 있고, 그 뷰에 대한 비트맵 정보를 갖고 하기 때문에 GPU만 사용  → 허나 앱이 처음에 레이어에 들어갈 콘텐츠를 제공해야함 ( 추후에 다시 설명 )
- Core animation은 자동으로 애니메이션을 이어주는 엔진
    
    → 시작좌표가 0,0이고 끝 좌표가 100, 100이라면 자동으로 그 사이를 자연스럽게 연결해줌
    
- 레이어가 갖고 있는 정보
    - 크기
    - 위치
    - 변환
    - 기준점 ( 뷰에는 없는 고유한 속성 )
        - 회전, 확대/축소가 일어날때 어느 점을 기준으로 변환할지
- 레이어는 두 가지 좌표계를 사용
    - 포인트 좌표계, 화면이나 부모 레이어 좌표계와 직접 연결 ex ) CGPoint(x: 200, y: 300)
        - postion
        - bounds
        - frame 등이 주로 사용
    - 단위 좌표계, 비율로 표현 ex ) CGPoint(x: 0.5, y: 0.5)
        - anchorPoint가 주로 사용
- iOS, macOS의 bounds 원점 (0, 0) 이 다름
    - iOS는 왼쪽 위
    - macOS는 왼쪽 아래
- 모든 좌표값은 Float로 지정 → 더 정밀한 위치 지정을 하기 위해서
- AnchorPoint는 해당 뷰에서 기준점이 어디인지 설정이고, Position은 상위 뷰에서 기준점을 어디에 둘지
    - A4 용지에서 포스트잇을 붙인 상황에서
        - 기본 포스트잇의 AnchorPoint는 중심, 내가 포스트잇의 중심을 200,300에 뒀음
        - 허나 여기서 포스트잇의 AnchorPoint를 왼쪽 위, 0,0에 배치한다면 똑같이 200,300에 중점을 배치해도 다른 뷰가 나옴 → 조심해야함
- 레이어는 변환할 수 있는 두 개의 변환 행렬을 갖고 있음
    - transform → 이 안에 포함된 모든 서브 레이어에 적용
    - sublayerTransform → 부모 레이어에는 영향 없음, 자식 레이어들만 적용
- 좌표값을 행렬 연산으로 바꿔 새로운 좌표를 만드는 방식으로 동작
    - 3D 좌표계를 지원하기에 점 하나를 (x,y,z,w)로 표현
    - 4 X 4행렬에 곱해서 변환된 좌표를 얻음
    
    ![image.png](/assets/images/coreanimation/core-1.png)
    
    → 이 변환을 **CATransform3D** 구조체로 표현  
    
- Core Animation에서의 세 가지 상태 버전의 레이어 트리
    1. 모델 레이어 트리 
        - 시작 및 끝점 등의 애니메이션이 목표값을 저장
    2. 프레젠테이션 트리
        - 애니메이션이 진행 중일 때, **중간 프레임들(지금 화면에 보이는 상태)** 을 저장하는 트리
            
            → 말 그대로 **현재 무대 위에 보여지는 장면**
            
    3. 랜더 트리
        - Core Animation 내부 전용, GPU가 실제로 그림을 그리는 데 쓰는 레이어 트리

→ 하나의 뷰에 대해 트리가 존재 

```
뷰 계층이 아래처럼 있다면

WindowView
 └─ ContentView
      └─ ButtonView
      
이에 따른 레이어 또한 존재함
-> 뷰 자체가 레이어를 갖고 있고 모든 뷰는 UIView를 상속하기 때문에

WindowLayer
 └─ ContentLayer
      └─ ButtonLayer
      
그럼 이 하나 하나의 레이어 ( WindowLayer, ContentLayer, ButtonLayer ) 마다 
3가지 상태 버전이 존재 ( 위에서 설명한 것과 같이 )
```

→ **레이어마다 모델/프레젠테이션/렌더 트리가 Core Animation 안에서 동시에 관리되면서 애니메이션이 실행된다.**

- **Layer-backed View vs Layer-hosting View**
    - iOS는 자동으로 레이어가 전부 붙지만 macOS는 붙지 않음
    
    → macOS는 자신이 원하는 뷰에만 레이어를 붙여서 오버헤드를 줄일 수 있지만, 관리는 직접해야함
       혹은 iOS 처럼 자동으로 붙여서 OS가 관리하도록 할 수 있다
    
- 주의점
    - 최대한 뷰의 속성을 통해 수정할 수 있는 부분은 뷰를 통해 수정, 레이어를 건들여야 하는 것만 레이어로 수정
        
        → 동기화 문제가 발생한다면 꼬이거나 이상이 생길 수 있기 때문에