---
layout: post
title: 27장 - ‘크고 작은 모든’ 서비스들
tags: [clean-architecture]
date: 2025-07-29 10:00:01 +0900
---


> 서비스 지향 '아키텍처'와 마이크로서비스 '아키텍처'는 최근에 큰 인기를 끌고 있다. 그 이유는 다음과 같다.
> 
> - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. 나중에 보겠지만, 이는 일부만 맞는 말이다.
> - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. 나중에 보겠지만, 이 역시도 일부만 맞는 말이다.

## 서비스 아키텍쳐

- 서비스 사용이 아키텍처에 해당한다는 개념은 명백히 사실이 아님
    - 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경 계에 의해 정의된다.
    - 단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과
    - 아키텍처 관점에서 꼭 중요하다고 볼 수는 없다.
- 모든 서비스가 반드시 아키텍처 관점에서 중요해야만 한다는 뜻은 아니다.
    - 기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관없이 큰 도움이 될 때가 많다.
    - 그러나 서비스 그 자체로는 아키텍처를 정의하지 않는다.
- 함수들의 구성 형태도 이와 비슷하다.
    - 모노리틱 시스템이나 컴포넌트 기반 시스템에서 아키텍처를 정의하는 요소는 바로 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다.
    - 반면 시스템의 나머지 많은 함수들은 행위를 서로 분리할 뿐이며, 아키텍처적으로는 전혀 중요하지 않다.
- 서비스도 마찬가지다.
    - 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.
    - 아키텍처적으로 중요한 서비스도 있지만, 중요하지 않는 서비스도 존재한다.
    - 이 장에서 우리가 관심을 가지는 서비스는 전자다.

## 서비스의 이점?

- 각 이점들을 확인해보자

### 결합 분리의 오류

- 서비스 사이의 결합이 확실하게 분리된다.
    - 각 서비스는 각자의 프로세서에서 실행되고, 다른 서비스의 변수나 함수에 접근할 수 없음
    - 각 서비스는 인터페이스 또한 잘 정의되어 있어야 함
- 일리는 있지만, 꼭 그런것만은 아님
    - 프로세서 내의, 또는 네트워크 상의 공유자원 때문에 결합할 가능성이 존재
    - 더욱이 서로 공유하는 데이터에 의해 이들을 더욱 강하게 결합됨
    
    ex) 
    
    - 서비스 사이를 오가는 데이터 레코드에 새로운 필드 추가
        - 이 필드를 사용해 동작하는 모든 서비스는 변경되어야 함
        - 서비스들은 이 필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하 게 조율해야 함
    
    → 서비스들은 이 데이터 레코드에 강하게 결합되고, 서비스들 사이는 서로 간접적으로 결합되어 버림
    
- 인터페이스가 잘 정의되어 있어야 한다는 이점에 대해서라면 이는 명백히 사실이다.
    - 하지만 함수의 경우에도 전혀 다르지 않다.
    - 서비스 인터페이스가 함수 인터페이스보다 더 엄밀하거나, 더 엄격하고, 더 잘 정의되는 것은 아니 다. 이러한 이점은 환상에 불과하다.

### 개발 및 배포 독립성의 오류

- 또 다른 이점은 전담팀이 서비스를 소유하고 운영한다는 점
- 데브옵스 전략의 일환으로 전담팀에서 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 질 수 있다.
    - 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.
    - 대규모 엔터 프라이즈 시스템을 독립적으로 개발하고 배포 가능한 수십, 수백, 수천 개의 서비스들을 이용하여 만들 수 있다고 믿는다.
    - 시스템의 개발, 유지보수, 운영 또한 비슷한 수의 독립적인 팀 단위로 분할할 수 있다고 여긴다.
- 이러한 믿음에도 어느 정도 일리가 있지만, 극히 일부일 뿐이다.
    1. 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도, 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실은 역사적으로 증명되어 왔다. 
        - 따라서 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.
    2. ‘결합 분리의 오류'에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것은 아니다. 
        - 데이터나 행위에서 어느 정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다.

### 야옹이 문제

- 9장에서 택시문제를 다시 생각해보자
    - 시스템은 해당 도시에서 운영되는 많은 택시 업체를 알고 있다
    - 고객은 승차 요청을 할 수 있다는 점을 상기
    - 고객은 승차 시간, 비용, 고급 택시 여부, 운전사 경력 등 다양한 기준에 따라 택시를 선택할 수 있다고 가정하자.
- 확장 가능한 시스템을 구축하고 싶었기에, 우리는 수많은 작은 마이크로 서비스를 기반으로 구축하기로 결정했다.
    - 개발팀 직원을 많은 소규모 팀으로 세분화했고, 각 팀이 팀 규모에 맞게 적당한 수의 서비스를 개발하고, 유지보수하며, 운영하는 책임을 지도록 했다.
    
    ![27-1](/assets/images/clean-architecture/27-1.png)
    
- 현재의 순서
    1. 모바일에서 택시를 찾음
    2. Taxi Finder가 찾고 Supplier를 통해 Selector에 제공
    3. 찾아진 택시를 선택
- 만약 여기서 고양이가 생기고, 순서는 동일하게 하지만 알러지로 인한 조건이 붙는다면 얼마나 코드를 수정해야할까?
    
    → 전부 다
    
    - 의심의 여지없이 야옹이 배달 기능을 추가하려면 개발과 배포 전략을 매우 신중하게 조정해야 한다.
- 다시 말해 이 서비스들은 모두 결합되어 있어서 독립적으로 개발하고, 배포하거나, 유지될 수 없다.
    - 이게 바로 횡단 관심사가 지닌 문제다.
    - 모든 소프트웨어시스템은 서비스 지향이든 아니든 이 문제에 직면하게 마련이다
    - 위의 서비스 다이어그램에서 묘사된 것과 같은 종류의 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약하다.

### 객체가 구출하다

- 컴포넌트 기반에서는 이 문제를 어떻게 해결했을까?
    
   ![27-2](/assets/images/clean-architecture/27-2.png)
    
    → SOLID
    
    - 다형적으로 확장할 수 있는 클래스 집합을 만들어 새로운 기능을 처리하도록 함
- Rides, Kittens 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴을 통해 오버라이드 함
- 택시 UI는 어쩔수 없이 교환을 해야하지만, 나머지는 수정하지 않아도 괜찮음

### 컴포넌트 기반 서비스

- 컴포넌트에서 Solid를 적용해서 해결한 것처럼 서비스에도 적용할 수 있을까? → YES!
- 굳이 서비스가 소규모 단일체일 필요는 없음
- 서비스에도 Solid를 적용해서 기존 코드를 건드리지 않고, 확장을 할 수 있음
    - 새로운 서비스를 추가한다면 jar 파일을 추가 → 기존 코드 건들이지 않아도 됨
        
        ![27-3](/assets/images/clean-architecture/27-3.png)
        

### 횡단 관심사

- 지금까지 배운건 아키텍쳐의 경계가 서비스 사이에 있지 않다.
    - 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할함
- 모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 다이어그램처럼 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
    - 이 서비스들은 시스템의 아키텍처 경계를 정의하지 않는다.
    - 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.
        
        ![27-4](/assets/images/clean-architecture/27-4.png)